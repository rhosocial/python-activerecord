<!-- README.md -->
# rhosocial-activerecord ($\rho_{\mathbf{AR}}$)

> **‚ö†Ô∏è Development Stage Notice:** This project is currently in the development stage. Features may be added or removed at any time, and there may be defects or inconsistencies with the actual implementation. Therefore, the documentation content may be subject to change at any time and is currently for reference only.

[![PyPI version](https://badge.fury.io/py/rhosocial-activerecord.svg)](https://badge.fury.io/py/rhosocial-activerecord)
[![Python](https://img.shields.io/pypi/pyversions/rhosocial-activerecord.svg)](https://pypi.org/project/rhosocial-activerecord/)
[![Tests](https://github.com/rhosocial/python-activerecord/actions/workflows/test.yml/badge.svg)](https://github.com/rhosocial/python-activerecord/actions)
[![Coverage Status](https://codecov.io/gh/rhosocial/python-activerecord/branch/main/graph/badge.svg)](https://app.codecov.io/gh/rhosocial/python-activerecord/tree/main)
[![Apache 2.0 License](https://img.shields.io/github/license/rhosocial/python-activerecord.svg)](https://github.com/rhosocial/python-activerecord/blob/main/LICENSE)
[![Powered by vistart](https://img.shields.io/badge/Powered_by-vistart-blue.svg)](https://github.com/vistart)

<div align="center">
    <img src="docs/images/logo.svg" alt="rhosocial ActiveRecord Logo" width="200"/>
    <h3>A Modern, Standalone ActiveRecord Implementation for Python</h3>
    <p><b>Zero ORM Dependencies ¬∑ Full Type Safety ¬∑ True Sync-Async Parity ¬∑ AI-Native Design</b></p>
</div>

## ü§ñ AI-Native Design: Built for LLMs and Code Agents

This project is designed from the ground up to work seamlessly with Large Language Models (LLMs) and AI coding assistants like **Claude**, **OpenCode**, **GitHub Copilot**, and others.

### Why AI-Native Matters

**Clear Architecture**: Expression-Dialect separation means LLMs can easily understand and generate correct code without ambiguity.

**Transparent SQL**: Every query object has a `.to_sql()` method‚ÄîAI agents can inspect generated SQL before execution, ensuring correctness.

**Type-Safe by Design**: Full Pydantic v2 integration with explicit type annotations makes it easy for LLMs to understand model structures and generate valid code.

**Comprehensive Context**: Built-in skills and commands for AI assistants:
- **`.claude/skills/`** - 5 specialized skills for Claude Code
- **`.opencode/commands/`** - 8 slash commands for OpenCode
- **`.opencode/hints.yml`** - Smart suggestions triggered by keywords

**Getting Started with AI**: Just ask your AI assistant:
> "Show me how to create a User model with rhosocial-activerecord"
> "Generate a query to find active users with their posts"
> "Explain the Expression-Dialect architecture"

## Philosophy: Built From Scratch, Not Wrapped

**Traditional ORM Architecture**: Your Code ‚Üí ORM API ‚Üí SQLAlchemy/Django ‚Üí Database Driver ‚Üí Database  
**Our Architecture**: Your Code ‚Üí rhosocial-activerecord ‚Üí Database Driver ‚Üí Database

We built this from the ground up with **only Pydantic** as a dependency. No SQLAlchemy underneath. No Django ORM wrapper. Just pure Python.

**Why This Matters:**
- **Zero Hidden Complexity** - No abstraction layers you can't control or optimize
- **Complete SQL Control** - Every query is generated by our code, optimized for each backend
- **Smaller Footprint** - Only one dependency (Pydantic), not an entire ORM ecosystem
- **Simpler Mental Model** - One layer to understand, not three

## Architecture Highlights

### üéØ Expression-Dialect Separation with Transparent SQL

Query structure and SQL generation are completely separated:
- **Expressions** define what you want (no SQL string concatenation)
- **Dialects** handle backend-specific SQL generation (SQLite, MySQL, PostgreSQL)
- **Result**: The same Python code generates optimal SQL for each database

**Debug-Friendly**: Every expression and query implements `ToSQLProtocol`‚Äîcall `.to_sql()` anytime to see exactly what SQL will be executed.

**Try it with your AI assistant:**

> üí¨ **"Explain how Expression-Dialect separation works in rhosocial-activerecord"**
> 
> üí¨ **"Show me how to use `.to_sql()` to debug a query before executing it"**
> 
> üí¨ **"Create a query that filters users by age and name, then show me the generated SQL"**
> 
> üí¨ **"What's the difference between SQLColumn and SQLLiteral expressions?"**

### üîÑ True Sync-Async Parity

Not async wrappers around sync code. Native implementations with identical APIs.

**Key Principle**: Same method names, same patterns, just add `await`.

**‚ö†Ô∏è Important Note**: Not all backends provide both sync and async versions simultaneously:
- **SQLite**: Full sync support via `SQLiteBackend`; async support (`AsyncSQLiteBackend`) is currently provided for testing purposes only and not considered production-ready
- **MySQL/PostgreSQL/Oracle/SQL Server**: Check the specific backend package documentation for sync/async availability

**Try it with your AI assistant:**

> üí¨ **"Show me the difference between sync and async APIs in rhosocial-activerecord"**
> 
> üí¨ **"Convert this synchronous code to asynchronous"**
> 
> üí¨ **"Which backends support async operations?"**
> 
> üí¨ **"Explain the Sync-Async Parity principle with examples"**

### üõ°Ô∏è Type-First Design with Pydantic v2

Every field is type-safe, validated, and IDE-friendly:
- Type-safe field definitions with runtime validation
- Full IDE autocomplete support
- No `Any` types in public APIs

**Try it with your AI assistant:**

> üí¨ **"Create a User model with Pydantic validation rules"**
> 
> üí¨ **"How do I add custom validators to my model fields?"**
> 
> üí¨ **"Show me how to use FieldProxy for type-safe queries"**
> 
> üí¨ **"Explain how Pydantic v2 integration works in this ORM"**

## Features

This project provides a comprehensive feature set for database operations. Instead of listing all features here (which would be overwhelming), **ask your AI assistant to explore them interactively**:

> üí¨ **"Show me all the features of rhosocial-activerecord"**

Your AI assistant will provide a well-organized overview including:
- **Query Building** - Expression-based WHERE, JOINs, aggregations, CTEs, window functions
- **Relationships** - belongs_to, has_one, has_many, has_many_through with eager loading
- **Developer Experience** - Transparent SQL, type-safe queries, AI-native design
- **Enterprise Features** - Optimistic locking, soft delete, timestamps, UUIDs, events

### Backend Support
- ‚úÖ **SQLite** - Built-in, zero additional dependencies
- üîÑ **MySQL/MariaDB** - Via `rhosocial-activerecord-mysql` package
- üîÑ **PostgreSQL** - Via `rhosocial-activerecord-postgres` package
- üîÑ **Oracle** - Via `rhosocial-activerecord-oracle` package
- üîÑ **SQL Server** - Via `rhosocial-activerecord-mssql` package

## Requirements

- **Python**: 3.8+ (Python 3.13t/3.14t free-threaded builds supported)
- **Core Dependency**: Pydantic 2.10+ (Python 3.8) or 2.12+ (Python 3.9+)
- **SQLite**: 3.25+ (if using built-in SQLite backend)

See [Python Version Support](docs/en_US/introduction/python_version_support.md) for detailed compatibility information.

## Installation

```bash
# Core package with SQLite support
pip install rhosocial-activerecord

# Optional database backends
pip install rhosocial-activerecord[mysql]      # MySQL support
pip install rhosocial-activerecord[postgres]   # PostgreSQL support

# All database backends
pip install rhosocial-activerecord[databases]
```

## Quick Start

Ask your AI assistant for help, or follow these simple steps:

### 1. Define a Model

```python
from rhosocial.activerecord import ActiveRecord
from rhosocial.activerecord.backend.impl.sqlite import SQLiteBackend
from typing import ClassVar
from pydantic import Field
from rhosocial.activerecord.base import FieldProxy

class User(ActiveRecord):
    __table_name__ = 'users'
    
    name: str = Field(max_length=100)
    email: str
    age: int = 0
    
    # Enable type-safe queries
    c: ClassVar[FieldProxy] = FieldProxy()

# Configure once
User.configure(SQLiteBackend("app.db"))
```

### 2. Use It

```python
# Create
user = User(name="Alice", email="alice@example.com")
user.save()

# Query
adults = User.query() \
    .where(User.c.age >= 18) \
    .order_by(User.c.name) \
    .all()

# Inspect SQL before execution
sql, params = User.query().where(User.c.age >= 18).to_sql()
print(f"SQL: {sql}")  # SELECT * FROM users WHERE age >= ?
```

## Working with AI Assistants

This project provides first-class support for AI coding assistants:

### For Claude Code Users

Use the built-in skills in `.claude/skills/`:

```bash
# Ask Claude to use a specific skill
@activerecord-pattern Show me how to create a model with relationships

@backend-development How do I add MySQL support?

@sync-async-parity Check if my code follows sync-async parity

@testing-guide Help me write tests for this feature

@expression-dialect Explain how the query system works
```

### For OpenCode Users

Use the built-in slash commands:

```bash
/test                    # Run the test suite
/test-feature query      # Run query feature tests
/lint                    # Check code style
/new-feature             # Create a new feature following project standards
/check-sync-async        # Verify sync-async parity
```

### For Other AI Assistants

Simply ask your AI assistant. The codebase is designed to be self-documenting:

- **Type annotations** guide the AI to generate correct code
- **Clear method names** make intent obvious
- **Docstrings** explain behavior
- **Transparent SQL** lets AI verify generated queries

Example prompts:
> "Generate a complete blog system with User, Post, and Comment models"
> "Show me how to use CTEs for recursive queries"
> "Create a migration to add soft delete to the Post model"
> "Explain the difference between ActiveQuery and CTEQuery"

## Documentation

- **[Getting Started Guide](docs/en_US/getting_started/)** - Installation and basic usage
- **[Modeling Guide](docs/en_US/modeling/)** - Defining models, fields, and relationships
- **[Querying Guide](docs/en_US/querying/)** - Complete query builder documentation
- **[Backend Development](docs/en_US/backend/)** - Creating custom database backends
- **[API Reference](https://docs.python-activerecord.dev.rho.social/api/)** - Full API documentation

## Contributing

We welcome contributions! Please see [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.

## License

[Apache License 2.0](LICENSE) - Copyright ¬© 2026 [vistart](https://github.com/vistart)

---

<div align="center">
    <p><b>Built with ‚ù§Ô∏è by the rhosocial team</b></p>
    <p><a href="https://github.com/rhosocial/python-activerecord">GitHub</a> ¬∑ <a href="https://docs.python-activerecord.dev.rho.social/">Documentation</a> ¬∑ <a href="https://pypi.org/project/rhosocial-activerecord/">PyPI</a></p>
</div>
