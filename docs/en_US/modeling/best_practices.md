# Modeling Best Practices

This document summarizes best practices when defining models with `rhosocial-activerecord`, helping you write more robust and maintainable code.

> ðŸ’¡ **AI Prompt:** "How do I design a good ActiveRecord model? What are the best practices?"

---

## 1. Model Naming Conventions

Consistent naming conventions significantly improve code readability and maintainability.

### Class Names: Singular PascalCase

```python
# âœ… Correct: Class names use singular form, PascalCase
class User(ActiveRecord):
    pass

class OrderItem(ActiveRecord):
    pass

class BlogPost(ActiveRecord):
    pass

# âŒ Wrong: Avoid plural forms
class Users(ActiveRecord):  # Don't do this
    pass

# âŒ Wrong: Avoid snake_case
class blog_post(ActiveRecord):  # Don't do this
    pass
```

### Table Names: Plural snake_case

```python
class User(ActiveRecord):
    @classmethod
    def table_name(cls) -> str:
        return "users"  # âœ… Plural form

class OrderItem(ActiveRecord):
    @classmethod
    def table_name(cls) -> str:
        return "order_items"  # âœ… Plural + snake_case
```

### Quick Reference

| Item | Convention | Example |
|-----|---------|------|
| Model Class | PascalCase, Singular | `User`, `OrderItem` |
| Table Name | snake_case, Plural | `users`, `order_items` |
| Field Name | snake_case | `first_name`, `created_at` |
| Foreign Key | `<table_name>_id` | `user_id`, `order_id` |
| Boolean | `is_<adjective>` or `has_<noun>` | `is_active`, `is_deleted`, `has_paid` |
| Timestamp | `created_at`, `updated_at` | Auto-generated by TimestampMixin |

> ðŸ’¡ **AI Prompt:** "What are the ActiveRecord model naming conventions?"

---

## 2. Field Design Principles

### 2.1 When to Use Optional

```python
from typing import Optional

class User(ActiveRecord):
    # âœ… Required: Username must be provided
    username: str
    
    # âœ… Optional: Email can be empty or verified later
    email: Optional[str] = None
    
    # âœ… Optional: User may not have uploaded an avatar yet
    avatar_url: Optional[str] = None
    
    # âœ… Default value: Auto-activate on creation
    is_active: bool = True
    
    # âœ… Default value: Auto-filled on creation
    created_at: Optional[datetime] = None
```

**Decision Guidelines:**

| Scenario | Recommended Approach | Example |
|-----|---------|------|
| DB Required, No Default | `field: type` | `username: str` |
| DB Required, Has Default | `field: type = default` | `is_active: bool = True` |
| DB Nullable | `field: Optional[type] = None` | `email: Optional[str] = None` |
| Auto-generated by DB | `field: Optional[type] = None` | `id: Optional[int] = None` |

### 2.2 Default Value Strategies

```python
from datetime import datetime
from pydantic import Field

class Post(ActiveRecord):
    # âœ… Use Python defaults (static values)
    status: str = "draft"
    view_count: int = 0
    is_published: bool = False
    
    # âœ… Use Field default factory (dynamic values)
    created_at: datetime = Field(default_factory=datetime.now)
    
    # âœ… Use Mixins to auto-handle (recommended)
    # Inherit TimestampMixin for automatic created_at and updated_at
```

**Recommended: Use Mixins for Common Fields:**

```python
from rhosocial.activerecord.field import TimestampMixin, UUIDMixin, SoftDeleteMixin

class Post(UUIDMixin, TimestampMixin, SoftDeleteMixin, ActiveRecord):
    """
    Automatically gets:
    - id: UUID primary key (from UUIDMixin)
    - created_at: Creation time (from TimestampMixin)
    - updated_at: Update time (from TimestampMixin)
    - deleted_at: Soft delete marker (from SoftDeleteMixin)
    """
    title: str
    content: str
```

### 2.3 Validation Rule Design

```python
from pydantic import Field, EmailStr

class User(ActiveRecord):
    # âœ… Basic validation: Length limits
    username: str = Field(..., min_length=3, max_length=50)
    
    # âœ… Format validation: Use Pydantic built-in types
    email: EmailStr  # Auto-validates email format
    
    # âœ… Numeric validation: Range limits
    age: int = Field(..., ge=0, le=150)  # 0-150 years
    
    # âœ… Regex validation: Custom formats
    phone: str = Field(..., pattern=r"^1[3-9]\d{9}$")  # Chinese mobile number
```

> ðŸ’¡ **AI Prompt:** "What are the commonly used validation parameters in Pydantic Field?"

---

## 3. Organizing Models in Large Projects

When projects grow, proper organization becomes crucial.

### 3.1 Organize by Module

```
my_project/
â”œâ”€â”€ models/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ base.py          # Base model configuration
â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py    # User, UserProfile
â”‚   â”‚   â””â”€â”€ queries.py   # User-related query classes
â”‚   â”œâ”€â”€ order/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py    # Order, OrderItem
â”‚   â”‚   â””â”€â”€ queries.py
â”‚   â””â”€â”€ product/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â””â”€â”€ models.py    # Product, Category
```

**models/base.py:**

```python
from rhosocial.activerecord.model import ActiveRecord
from rhosocial.activerecord.base import FieldProxy
from rhosocial.activerecord.backend.impl.sqlite import SQLiteBackend
from typing import ClassVar

# Configure base backend
_base_backend = None

def get_backend():
    global _base_backend
    if _base_backend is None:
        from rhosocial.activerecord.backend.impl.sqlite.config import SQLiteConnectionConfig
        config = SQLiteConnectionConfig(database='app.db')
        _base_backend = SQLiteBackend(config)
    return _base_backend

class BaseModel(ActiveRecord):
    """Project base model class."""
    
    c: ClassVar[FieldProxy] = FieldProxy()
    
    @classmethod
    def configure_backend(cls):
        """Configure backend (call at app startup)."""
        if not hasattr(cls, '_backend_configured'):
            cls.configure(get_backend())
            cls._backend_configured = True
```

**models/user/models.py:**

```python
from typing import Optional
from pydantic import Field
from ..base import BaseModel

class User(BaseModel):
    """User model."""
    
    id: Optional[int] = None
    username: str = Field(..., max_length=50)
    email: str
    
    @classmethod
    def table_name(cls) -> str:
        return 'users'

class UserProfile(BaseModel):
    """User profile model."""
    
    id: Optional[int] = None
    user_id: int
    bio: Optional[str] = None
    avatar: Optional[str] = None
    
    @classmethod
    def table_name(cls) -> str:
        return 'user_profiles'
```

### 3.2 Organize by Domain (DDD Style)

```
my_project/
â”œâ”€â”€ domains/
â”‚   â”œâ”€â”€ user/
â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py      # User model
â”‚   â”‚   â”œâ”€â”€ repository.py  # Data access layer
â”‚   â”‚   â””â”€â”€ services.py    # Business logic
â”‚   â””â”€â”€ order/
â”‚       â”œâ”€â”€ __init__.py
â”‚       â”œâ”€â”€ models.py      # Order, OrderItem
â”‚       â””â”€â”€ services.py
```

### 3.3 Query Class Organization

Encapsulate complex queries in dedicated query classes:

```python
# models/user/queries.py
from rhosocial.activerecord.query import ActiveQuery
from datetime import datetime, timedelta

class UserQuery(ActiveQuery):
    """User-specific query class."""
    
    def active(self):
        """Only query active users."""
        return self.where(self.model_class.c.is_active == True)
    
    def recently_joined(self, days: int = 30):
        """Query recently registered users."""
        cutoff = datetime.now() - timedelta(days=days)
        return self.where(self.model_class.c.created_at >= cutoff)
    
    def with_email(self):
        """Only query users with email."""
        return self.where(self.model_class.c.email.is_not(None))

# models/user/models.py
class User(BaseModel):
    __query_class__ = UserQuery  # Bind custom query class
    # ... field definitions

# Usage
recent_active_users = User.query().active().recently_joined(7).all()
```

> ðŸ’¡ **AI Prompt:** "How do I organize ActiveRecord models in large projects?"

---

## 4. Version Control Strategy

### 4.1 Model Changes and Database Migrations

When models change, database structure needs to be updated accordingly.

**Basic Principles:**

1. **Never directly modify field types of released models** (may cause data loss)
2. **Use defaults or allow null when adding new fields**
3. **Confirm data is backed up or migrated before removing fields**
4. **Rename fields in two steps: Add new field â†’ Copy data â†’ Remove old field**

```python
# âœ… Safe: Add optional fields
class User(ActiveRecord):
    # New field, allows null, existing users will use None
    phone_number: Optional[str] = None
    
    # New field, has default value
    is_vip: bool = False
```

### 4.2 Using Alembic for Migrations

While `rhosocial-activerecord` doesn't provide migration tools itself, you can use Alembic.

**alembic/env.py Configuration:**

```python
# Generate migration scripts from models
from myapp.models import User, Order, Product

target_metadata = ActiveRecord.metadata

def run_migrations_offline() -> None:
    # ... Standard Alembic configuration
    context.configure(
        url=DATABASE_URL,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
    )
```

**Migration Workflow:**

```bash
# 1. Modify model code
# 2. Generate migration script
alembic revision --autogenerate -m "Add user phone_number"

# 3. Review generated script for correctness
# 4. Run migration
alembic upgrade head
```

### 4.3 Backward Compatibility

Maintain backward compatibility when making breaking changes:

```python
class User(ActiveRecord):
    # Old field (marked deprecated, but kept)
    name: Optional[str] = None  # Deprecated, use first_name + last_name
    
    # New fields
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    
    @property
    def full_name(self) -> str:
        """Backward compatibility."""
        if self.first_name or self.last_name:
            return f"{self.first_name or ''} {self.last_name or ''}".strip()
        return self.name or ""  # Compatible with old data
```

> ðŸ’¡ **AI Prompt:** "How do I safely perform ActiveRecord model changes and database migrations?"

---

## 5. Performance Optimization: When to Add Indexes

Indexes can significantly improve query performance, but also increase write overhead and storage space.

### 5.1 Scenarios Where You Should Add Indexes

```python
# âœ… Foreign key fields (JOIN queries)
class Order(ActiveRecord):
    user_id: int  # Should index: frequently JOIN with users table

# âœ… Fields frequently used in WHERE conditions
class User(ActiveRecord):
    email: str    # Should index: frequently query by email
    username: str # Should index: frequently query by username

# âœ… Fields frequently used for sorting
class Post(ActiveRecord):
    created_at: datetime  # Should index: frequently ORDER BY created_at
    published_at: Optional[datetime]  # Should index: frequently sort by publish time
```

### 5.2 Scenarios Where You Should NOT Add Indexes

```python
# âŒ Fields rarely queried
class User(ActiveRecord):
    bio: Optional[str] = None  # Rarely query by bio, don't index

# âŒ Fields with low cardinality (like booleans)
class User(ActiveRecord):
    is_active: bool = True  # Most users are True, low cardinality, don't index

# âŒ Fields frequently updated
class Product(ActiveRecord):
    view_count: int = 0  # Frequently updated, index impacts performance
```

### 5.3 Composite Indexes

Use composite indexes when multiple fields are frequently queried together:

```sql
-- Frequently query: WHERE status = 'active' AND category_id = 5
CREATE INDEX idx_products_status_category ON products(status, category_id);

-- Frequently query: WHERE user_id = 1 ORDER BY created_at DESC
CREATE INDEX idx_orders_user_created ON orders(user_id, created_at DESC);
```

**Composite Index Field Order Principles:**
1. **Equality filter fields first** (`=` or `IN`)
2. **Sort fields second**
3. **Range filter fields last** (`>`, `<`, `BETWEEN`)

### 5.4 Index Best Practices

```python
class User(ActiveRecord):
    """User model - Index examples."""
    
    # Primary key is automatically indexed
    id: Optional[int] = None
    
    # âœ… Unique index: Email must be unique
    email: str
    # SQL: CREATE UNIQUE INDEX idx_users_email ON users(email);
    
    # âœ… Normal index: Frequently query by username
    username: str
    # SQL: CREATE INDEX idx_users_username ON users(username);
    
    # âœ… Composite index: Frequently query by status + registration time
    is_active: bool = True
    created_at: datetime
    # SQL: CREATE INDEX idx_users_active_created ON users(is_active, created_at);
    
    # âŒ No index needed: Rarely queried
    bio: Optional[str] = None
```

### 5.5 Using EXPLAIN to Analyze Queries

```python
# View query plan
query = User.query().where(User.c.email == 'alice@example.com')
sql, params = query.to_sql()
print(f"SQL: {sql}")

# Execute in database client:
# EXPLAIN QUERY PLAN SELECT * FROM users WHERE email = 'alice@example.com';
```

**Ideal Query Plan:**
- `SEARCH TABLE users USING INDEX idx_users_email (email=?)`

**Query Plan Needing Optimization:**
- `SCAN TABLE users` (Full table scan, slow!)

### 5.6 Performance Optimization Checklist

- [ ] All foreign key fields are indexed
- [ ] Frequently queried fields are indexed
- [ ] Frequently sorted fields are indexed
- [ ] Avoid indexes on low-cardinality fields
- [ ] Avoid indexes on frequently updated fields
- [ ] Regularly use `EXPLAIN` to check slow queries
- [ ] Regularly use `VACUUM` (SQLite) or `OPTIMIZE TABLE` (MySQL) for maintenance

> ðŸ’¡ **AI Prompt:** "When should I add database indexes? When should I avoid them?"

---

## 6. Security Best Practices

### 6.1 Prevent SQL Injection

```python
# âœ… Safe: Use parameterized queries
users = User.query().where(User.c.email == user_input).all()

# âœ… Safe: Use FieldProxy
User.query().where(User.c.status == 'active')

# âŒ Dangerous: Direct SQL concatenation
# User.query().where(f"email = '{user_input}'")  # Never do this!
```

### 6.2 Sensitive Data Handling

```python
from pydantic import Field

class User(ActiveRecord):
    # âœ… Passwords must always be hashed
    password_hash: str
    
    # Don't provide password field, provide setter method instead
    def set_password(self, plain_password: str):
        import bcrypt
        self.password_hash = bcrypt.hashpw(
            plain_password.encode(), 
            bcrypt.gensalt()
        ).decode()
    
    def check_password(self, plain_password: str) -> bool:
        import bcrypt
        return bcrypt.checkpw(
            plain_password.encode(), 
            self.password_hash.encode()
        )
```

### 6.3 Data Validation

```python
from pydantic import Field, validator

class User(ActiveRecord):
    email: str
    
    @validator('email')
    def validate_email(cls, v):
        if '@' not in v:
            raise ValueError('Invalid email format')
        return v.lower()  # Normalize to lowercase
```

> ðŸ’¡ **AI Prompt:** "What are the security best practices for ActiveRecord models?"

---

## 7. Summary

Good model design should:

âœ… **Clear Naming**: Class names singular PascalCase, table names plural snake_case  
âœ… **Explicit Types**: Reasonable use of Optional, distinguish required/optional fields  
âœ… **Adequate Validation**: Use Pydantic Field for data validation  
âœ… **Organized Structure**: Large projects organized by module or domain  
âœ… **Version Controllable**: Use Alembic to manage database migrations  
âœ… **Performance Optimized**: Add indexes on appropriate fields  
âœ… **Secure**: Prevent SQL injection, encrypt sensitive data storage  

---

## See Also

- [Fields](fields.md) â€” Deep dive into FieldProxy and field types
- [Mixins](mixins.md) â€” Reuse common fields and behaviors
- [Validation & Lifecycle](validation.md) â€” Pydantic validation and model hooks
- [Query Cheatsheet](../querying/cheatsheet.md) â€” Efficient query techniques
