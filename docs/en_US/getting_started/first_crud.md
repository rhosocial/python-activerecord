# Your First CRUD Application

In this tutorial, we'll build a simple **Todo application** from scratch. You'll learn how to create, read, update, and delete data using `rhosocial-activerecord`.

## What You'll Build

A command-line Todo app where you can:
- âœ… Add new tasks
- ğŸ“‹ List all tasks (with filtering)
- âœï¸ Mark tasks as complete
- ğŸ—‘ï¸ Delete tasks

## Quick Start with AI

> ğŸ’¡ **AI Prompt:** "I'm a Python developer. Help me create a complete Todo CRUD application using rhosocial-activerecord with SQLite. Include: (1) Model definition with id, title, description, completed, created_at fields, (2) Database configuration, (3) All CRUD operations (create, read, update, delete), and (4) A simple CLI interface. Use Python 3.8+ syntax and include proper imports."
>
> Copy the prompt above and paste it to your AI assistant to get a working CRUD application in seconds!

## Prerequisites

- Python 3.8 or higher installed
- Basic knowledge of Python (functions, classes)
- A text editor or IDE

## Step 1: Project Setup

### Create Project Directory

```bash
mkdir my_first_crud
cd my_first_crud
python -m venv venv
```

### Activate Virtual Environment

```bash
# On macOS/Linux:
source venv/bin/activate

# On Windows:
venv\Scripts\activate
```

### Install Dependencies

```bash
pip install rhosocial-activerecord
```

> ğŸ’¡ **AI Prompt:** "What is a virtual environment and why should I use one?"

## Step 2: Create the Database Schema

Before writing Python code, let's understand what data we need to store:

**Todo Task:**
- `id`: Unique identifier (auto-generated)
- `title`: What needs to be done
- `description`: More details (optional)
- `completed`: Whether it's done (True/False)
- `created_at`: When the task was created

## Step 3: Define the Model

Create a file named `todo.py`:

```python
# todo.py
from typing import ClassVar, Optional
from datetime import datetime
from pydantic import Field
from rhosocial.activerecord.model import ActiveRecord
from rhosocial.activerecord.base import FieldProxy
from rhosocial.activerecord.backend.impl.sqlite import SQLiteBackend
from rhosocial.activerecord.backend.impl.sqlite.config import SQLiteConnectionConfig


class Todo(ActiveRecord):
    """Todo task model."""
    
    # Required: Enable type-safe query building
    c: ClassVar[FieldProxy] = FieldProxy()
    
    # Fields
    id: Optional[int] = None  # Auto-generated by database
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = False
    created_at: Optional[datetime] = None
    
    @classmethod
    def table_name(cls) -> str:
        return 'todos'


# Configure database
config = SQLiteConnectionConfig(database='todo.db')
Todo.configure(config, SQLiteBackend)

# Create table (in production, use migrations instead)
Todo.__backend__.execute("""
    CREATE TABLE IF NOT EXISTS todos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        description TEXT,
        completed BOOLEAN DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
""")
```

**Line-by-line explanation:**

```python
from typing import ClassVar, Optional
```
- `ClassVar`: Tells Pydantic this is a class variable, not a model field
- `Optional`: Indicates a field can be None

```python
from rhosocial.activerecord.base import FieldProxy
```
- `FieldProxy`: You must import and define this yourself to enable type-safe queries like `Todo.c.completed == True`

```python
class Todo(ActiveRecord):
```
- Your model inherits from `ActiveRecord`, giving it database capabilities

```python
c: ClassVar[FieldProxy] = FieldProxy()
```
- **You define this**: The field proxy is not built-inâ€”every model must define it to enable type-safe queries
- You can name it anything (`c`, `fields`, `col`, etc.), `c` is just a convention
- Without it, you can't do type-safe queries!

```python
id: Optional[int] = None
```
- Primary key, auto-generated by SQLite
- `Optional` because it's None before saving

```python
title: str = Field(..., min_length=1, max_length=200)
```
- Pydantic validation: title must be 1-200 characters
- `...` means "required field"

```python
completed: bool = False
```
- Boolean field with default value `False`

```python
Todo.configure(config, SQLiteBackend)
```
- Connects the model to the SQLite database

> ğŸ’¡ **AI Prompt:** "Explain what FieldProxy does and why it's needed for type-safe queries."

## Step 4: Create (Add Tasks)

Add this to your `todo.py`:

```python
# Add to todo.py

def add_task(title: str, description: str = None) -> Todo:
    """Add a new task."""
    task = Todo(
        title=title,
        description=description,
        completed=False
    )
    task.save()  # This inserts into database
    print(f"âœ… Added task: {task.title} (ID: {task.id})")
    return task


# Test it
if __name__ == "__main__":
    # Add some tasks
    add_task("Learn rhosocial-activerecord", "Complete the tutorial")
    add_task("Build a Todo app", "Create a working application")
    add_task("Review the code", "Understand each line")
```

**Run it:**
```bash
python todo.py
```

**Output:**
```
âœ… Added task: Learn rhosocial-activerecord (ID: 1)
âœ… Added task: Build a Todo app (ID: 2)
âœ… Added task: Review the code (ID: 3)
```

**Explanation:**
```python
task = Todo(title=title, description=description)
```
- Creates a new Todo instance (not yet in database)

```python
task.save()
```
- **INSERT** operation: Saves to database
- `task.id` is now populated with the auto-generated ID

> ğŸ’¡ **AI Prompt:** "What's the difference between creating an instance and calling save()?"

## Step 5: Read (List Tasks)

Add these functions to `todo.py`:

```python
# Add to todo.py

def list_all_tasks():
    """List all tasks."""
    tasks = Todo.query().order_by((Todo.c.created_at, "DESC")).all()
    
    print("\nğŸ“‹ All Tasks:")
    print("-" * 60)
    for task in tasks:
        status = "âœ…" if task.completed else "â¬œ"
        print(f"{status} [{task.id}] {task.title}")
        if task.description:
            print(f"   {task.description}")
    print()


def list_pending_tasks():
    """List only incomplete tasks."""
    tasks = Todo.query() \
        .where(Todo.c.completed == False) \
        .order_by((Todo.c.created_at, "ASC")) \
        .all()
    
    print("\nâ³ Pending Tasks:")
    print("-" * 60)
    for task in tasks:
        print(f"â¬œ [{task.id}] {task.title}")
    print()


def find_task_by_id(task_id: int) -> Optional[Todo]:
    """Find a task by its ID."""
    return Todo.find(task_id)


# Update main block
if __name__ == "__main__":
    # Comment out add_task calls to avoid duplicates
    # add_task("Learn rhosocial-activerecord")
    
    list_all_tasks()
    list_pending_tasks()
    
    # Find specific task
    task = find_task_by_id(1)
    if task:
        print(f"Found task: {task.title}")
```

**Explanation:**

```python
Todo.query().order_by((Todo.c.created_at, "DESC")).all()
```
- `.query()` - Start building a query
- `.order_by((Todo.c.created_at, "DESC"))` - Sort by creation time, newest first
- `.all()` - Execute query and return all results

```python
.where(Todo.c.completed == False)
```
- Filter: only tasks where completed is False
- `Todo.c.completed` is type-safe (IDE will autocomplete!)

```python
Todo.find(task_id)
```
- Shortcut for getting by primary key
- Returns `None` if not found

> ğŸ’¡ **AI Prompt:** "Show me different ways to filter and sort tasks in this Todo app."

## Step 6: Update (Complete Tasks)

Add the update function:

```python
# Add to todo.py

def complete_task(task_id: int) -> bool:
    """Mark a task as completed."""
    task = Todo.find(task_id)
    if not task:
        print(f"âŒ Task {task_id} not found")
        return False
    
    task.completed = True
    task.save()  # This performs UPDATE
    print(f"âœ… Completed task: {task.title}")
    return True


def update_task_title(task_id: int, new_title: str) -> bool:
    """Update a task's title."""
    task = Todo.find(task_id)
    if not task:
        print(f"âŒ Task {task_id} not found")
        return False
    
    task.title = new_title
    task.save()
    print(f"âœï¸ Updated task {task_id}: {new_title}")
    return True


# Update main block
if __name__ == "__main__":
    complete_task(1)  # Complete task with ID 1
    update_task_title(2, "Build an amazing Todo app")
    list_all_tasks()
```

**Explanation:**
```python
task.completed = True
task.save()
```
- Modify the attribute
- `.save()` automatically detects it's an existing record (has `id`)
- Performs **UPDATE** instead of INSERT

> ğŸ’¡ **AI Prompt:** "How does rhosocial-activerecord know whether to INSERT or UPDATE?"

## Step 7: Delete (Remove Tasks)

Add the delete function:

```python
# Add to todo.py

def delete_task(task_id: int) -> bool:
    """Delete a task."""
    task = Todo.find(task_id)
    if not task:
        print(f"âŒ Task {task_id} not found")
        return False
    
    title = task.title  # Save for confirmation message
    task.delete()  # This removes from database
    print(f"ğŸ—‘ï¸ Deleted task: {title}")
    return True


# Update main block
if __name__ == "__main__":
    delete_task(3)  # Delete task with ID 3
    list_all_tasks()
```

**Explanation:**
```python
task.delete()
```
- **DELETE** operation
- Removes the row from database
- The Python object still exists but is "detached"

## Step 8: Interactive CLI (Optional)

Let's make it interactive. Create `todo_cli.py`:

```python
# todo_cli.py
from todo import Todo, add_task, list_all_tasks, list_pending_tasks, complete_task, delete_task


def show_menu():
    print("\n" + "="*60)
    print("ğŸ“ Todo App")
    print("="*60)
    print("1. Add task")
    print("2. List all tasks")
    print("3. List pending tasks")
    print("4. Complete task")
    print("5. Delete task")
    print("6. Exit")
    print("="*60)


def main():
    while True:
        show_menu()
        choice = input("\nChoose an option (1-6): ").strip()
        
        if choice == "1":
            title = input("Task title: ")
            desc = input("Description (optional): ") or None
            add_task(title, desc)
            
        elif choice == "2":
            list_all_tasks()
            
        elif choice == "3":
            list_pending_tasks()
            
        elif choice == "4":
            task_id = input("Task ID to complete: ")
            if task_id.isdigit():
                complete_task(int(task_id))
            else:
                print("âŒ Please enter a valid number")
                
        elif choice == "5":
            task_id = input("Task ID to delete: ")
            if task_id.isdigit():
                delete_task(int(task_id))
            else:
                print("âŒ Please enter a valid number")
                
        elif choice == "6":
            print("ğŸ‘‹ Goodbye!")
            break
            
        else:
            print("âŒ Invalid option. Please choose 1-6.")


if __name__ == "__main__":
    main()
```

**Run it:**
```bash
python todo_cli.py
```

## Complete Code

Here's the complete `todo.py`:

<details>
<summary>Click to expand complete code</summary>

```python
# todo.py - Complete CRUD Example
from typing import ClassVar, Optional
from datetime import datetime
from pydantic import Field
from rhosocial.activerecord.model import ActiveRecord
from rhosocial.activerecord.base import FieldProxy
from rhosocial.activerecord.backend.impl.sqlite import SQLiteBackend
from rhosocial.activerecord.backend.impl.sqlite.config import SQLiteConnectionConfig


class Todo(ActiveRecord):
    """Todo task model."""
    
    c: ClassVar[FieldProxy] = FieldProxy()
    
    id: Optional[int] = None
    title: str = Field(..., min_length=1, max_length=200)
    description: Optional[str] = Field(default=None, max_length=1000)
    completed: bool = False
    created_at: Optional[datetime] = None
    
    @classmethod
    def table_name(cls) -> str:
        return 'todos'


# Configure database
config = SQLiteConnectionConfig(database='todo.db')
Todo.configure(config, SQLiteBackend)

# Create table
Todo.__backend__.execute("""
    CREATE TABLE IF NOT EXISTS todos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        title TEXT NOT NULL,
        description TEXT,
        completed BOOLEAN DEFAULT 0,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
""")


# CRUD Operations
def add_task(title: str, description: str = None) -> Todo:
    """Add a new task."""
    task = Todo(title=title, description=description, completed=False)
    task.save()
    print(f"âœ… Added task: {task.title} (ID: {task.id})")
    return task


def list_all_tasks():
    """List all tasks."""
    tasks = Todo.query().order_by((Todo.c.created_at, "DESC")).all()
    
    print("\nğŸ“‹ All Tasks:")
    print("-" * 60)
    for task in tasks:
        status = "âœ…" if task.completed else "â¬œ"
        print(f"{status} [{task.id}] {task.title}")
        if task.description:
            print(f"   {task.description}")
    print()


def list_pending_tasks():
    """List only incomplete tasks."""
    tasks = Todo.query() \
        .where(Todo.c.completed == False) \
        .order_by((Todo.c.created_at, "ASC")) \
        .all()
    
    print("\nâ³ Pending Tasks:")
    print("-" * 60)
    for task in tasks:
        print(f"â¬œ [{task.id}] {task.title}")
    print()


def find_task_by_id(task_id: int) -> Optional[Todo]:
    """Find a task by its ID."""
    return Todo.find(task_id)


def complete_task(task_id: int) -> bool:
    """Mark a task as completed."""
    task = Todo.find(task_id)
    if not task:
        print(f"âŒ Task {task_id} not found")
        return False
    
    task.completed = True
    task.save()
    print(f"âœ… Completed task: {task.title}")
    return True


def update_task_title(task_id: int, new_title: str) -> bool:
    """Update a task's title."""
    task = Todo.find(task_id)
    if not task:
        print(f"âŒ Task {task_id} not found")
        return False
    
    task.title = new_title
    task.save()
    print(f"âœï¸ Updated task {task_id}: {new_title}")
    return True


def delete_task(task_id: int) -> bool:
    """Delete a task."""
    task = Todo.find(task_id)
    if not task:
        print(f"âŒ Task {task_id} not found")
        return False
    
    title = task.title
    task.delete()
    print(f"ğŸ—‘ï¸ Deleted task: {title}")
    return True


# Demo
if __name__ == "__main__":
    # Add sample tasks (run once, then comment out)
    # add_task("Learn rhosocial-activerecord", "Complete the tutorial")
    # add_task("Build a Todo app", "Create a working application")
    # add_task("Review the code", "Understand each line")
    
    # Demonstrate all operations
    list_all_tasks()
    list_pending_tasks()
```

</details>

## What You've Learned

âœ… **Create**: `Model(**data).save()` â†’ INSERT  
âœ… **Read**: `Model.query().where(...).all()` â†’ SELECT  
âœ… **Update**: Modify attributes, then `.save()` â†’ UPDATE  
âœ… **Delete**: `.delete()` â†’ DELETE  

## Next Steps

- Try adding validation (e.g., prevent empty titles)
- Add due dates to tasks
- Implement batch operations (complete multiple tasks)
- Read about [Querying](../querying/README.md) for more advanced features

## See Also

- [Configuration](configuration.md) â€” Database setup details
- [Querying](../querying/README.md) â€” Advanced query features
- [Common Errors](troubleshooting.md) â€” If you run into issues
