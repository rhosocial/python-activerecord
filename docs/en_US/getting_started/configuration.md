# Database Configuration

After defining ActiveRecord models, you still cannot immediately access the database backend to perform operations. `rhosocial-activerecord` requires explicit backend configuration before executing database operations. Once configured, you can access the corresponding database and execute queries. Specifically, if you only want to see the SQL results of queries without caring about the actual backend, you can use the dummy backend.

> ðŸ’¡ **AI Prompt Example**: "I defined an ActiveRecord model, but calling save() throws an error saying no backend is configured, what should I do?"

## SQLite Configuration

Currently, SQLite is the primary supported backend for production usage. After configuring the SQLite backend, you can perform real database operations.

```python
from rhosocial.activerecord.model import ActiveRecord
from rhosocial.activerecord.backend.impl.sqlite import SQLiteBackend, SQLiteConnectionConfig

# 1. Create a configuration object
config = SQLiteConnectionConfig(
    database='my_database.db',  # Or ':memory:' for in-memory database
    timeout=5.0
)

# 2. Configure the base ActiveRecord class or a specific Model
# This sets the default backend for all models that inherit from ActiveRecord
ActiveRecord.configure(config, SQLiteBackend)

# 3. After configuration, you can perform database operations
user = User(name="John Doe", email="john@example.com")
user.save()  # This will actually save to the SQLite database

# 4. You can also view the generated SQL statements
sql, params = User.query().where(User.c.name == "John Doe").to_sql()
print(f"SQL: {sql}")
print(f"Parameters: {params}")
```

> ðŸ’¡ **AI Prompt Example**: "I want to know what SQL statement this query would generate, but I don't want to actually execute it, is there a way?"

## Shared Backend Instance

In a real application, you want all your models to share the same database connection pool. The framework handles this automatically if you configure the base class or the first model.

If you have multiple databases, you can configure models individually:

```python
# Configure User model to use DB1
User.configure(config1, SQLiteBackend)

# Configure Post model to share the backend with User (Recommended)
# This ensures they use the same connection and transaction context
Post.__backend__ = User.__backend__
Post.__connection_config__ = User.__connection_config__
Post.__backend_class__ = User.__backend_class__
```

## Dummy Backend Configuration

If you only want to see the SQL generated by queries without executing actual database operations, you can use the Dummy backend. This is very useful for debugging and testing.

```python
from rhosocial.activerecord.model import ActiveRecord
from rhosocial.activerecord.backend.impl.dummy import DummyBackend
from rhosocial.activerecord.backend.config import ConnectionConfig

# 1. Create a configuration object
config = ConnectionConfig()

# 2. Configure to use Dummy backend
ActiveRecord.configure(config, DummyBackend)

# 3. Now you can generate SQL but cannot perform actual database operations
# This code works fine, generating SQL statements
sql, params = User.query().where(User.c.name == "John Doe").to_sql()
print(f"SQL: {sql}")
print(f"Parameters: {params}")

# But this code will throw an exception because Dummy backend doesn't support real database operations
# user.save()  # This would raise NotImplementedError
```

> ðŸ’¡ **AI Prompt Example**: "I want to test my query logic without connecting to a database, what should I do?"

## Async Configuration (Preview)

While the core logic is async-ready, the current drivers are synchronous. Async driver support (e.g., `aiosqlite`) is planned for future releases.

If you need async support, you can use AsyncDummyBackend to test SQL generation for async queries:

```python
from rhosocial.activerecord.model import AsyncActiveRecord
from rhosocial.activerecord.backend.impl.dummy import AsyncDummyBackend
from rhosocial.activerecord.backend.config import ConnectionConfig

# Configure async Dummy backend
config = ConnectionConfig()
AsyncActiveRecord.configure(config, AsyncDummyBackend)

# Generate SQL for async queries
sql, params = await User.query().where(User.c.name == "John Doe").to_sql()
print(f"Async SQL: {sql}")
```
