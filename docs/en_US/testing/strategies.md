# Testing Strategies

rhosocial-activerecord recommends adopting targeted testing strategies based on the different characteristics of the components being tested (ActiveRecord models vs Query objects).

## 1. ActiveRecord Testing Strategy

For `ActiveRecord` models, focus on metadata definitions, field expressions, and persistence operations.

### Scope
*   **Metadata**: Verify that `table_name()` and `primary_key()` return the correct values.
*   **Field Proxies**: Verify that the SQL segments and parameter tuples constructed by `User.c.field` expressions are correct.
*   **Persistence**: Verify the actual effects of `save()` (INSERT/UPDATE) and `delete()` operations.

### Example

```python
from rhosocial.activerecord.backend.impl.dummy import DummyBackend
from rhosocial.activerecord.backend.impl.sqlite import SQLiteBackend, SQLiteConnectionConfig

def test_user_metadata():
    """Test table name and primary key"""
    assert User.table_name() == "users"
    assert User.primary_key() == "id"

def test_field_expression_sql():
    """Test SQL generated by field expressions (using DummyBackend)"""
    # Configure DummyBackend to support SQL generation
    User.configure(None, DummyBackend)
    
    # Use the query builder to verify expressions
    # e.g., verifying User.c.username == 'alice'
    query = User.query().where(User.c.username == 'alice')
    sql, params = query.to_sql()
    
    assert 'WHERE "users"."username" = ?' in sql
    assert params == ('alice',)

def test_user_persistence():
    """Test save and delete (using SQLite in-memory database)"""
    # Configure SQLite in-memory database
    config = SQLiteConnectionConfig(database=':memory:')
    User.configure(config, SQLiteBackend)
    
    # Create table (usually done in a fixture)
    with User.connection() as conn:
        conn.execute(f"CREATE TABLE {User.table_name()} (id INTEGER PRIMARY KEY, username TEXT)")
    
    # Test Save
    user = User(username="bob")
    user.save()
    assert user.id is not None
    
    # Test Delete
    user.delete()
    assert User.query().where(User.c.id == user.id).one() is None
```

## 2. ActiveQuery & CTEQuery Testing Strategy

For query builders (`ActiveQuery`, `CTEQuery`), focus on SQL construction logic and query execution results.

### Scope
*   **Query Conditions**: Verify SQL statements and parameter tuples constructed by method chains like `.where()`, `.select()`, `.join()`.
*   **Return Values**: Verify the return results of `.one()`, `.all()`, `.aggregate()` in a real data environment.

### Example

```python
def test_query_construction():
    """Test query construction (Zero-IO)"""
    User.configure(None, DummyBackend)
    
    # Complex query construction
    query = User.query() \
        .where(User.c.age > 18) \
        .order_by((User.c.created_at, "DESC")) \
        .limit(10)
        
    sql, params = query.to_sql()
    
    assert 'WHERE "users"."age" > ?' in sql
    assert 'ORDER BY "users"."created_at" DESC' in sql
    assert 'LIMIT ?' in sql
    assert 18 in params
    assert 10 in params

def test_query_execution_results():
    """Test query return values (Integration)"""
    # Assuming SQLite in-memory database is configured and data is pre-populated
    # User(username="alice", age=20).save()
    # User(username="bob", age=15).save()
    
    # Test .all()
    adults = User.query().where(User.c.age >= 18).all()
    assert len(adults) == 1
    assert adults[0].username == "alice"
    
    # Test .aggregate() (CTEQuery or normal query)
    stats = User.query().select(User.c.age).aggregate()
    # Verify returning a list of dictionaries instead of models
    assert isinstance(stats[0], dict)
```
