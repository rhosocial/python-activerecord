# æ ¸å¿ƒç‰¹æ€§ä¹‹æ—… (A Tour of Key Features)

ä¸è¦è¢«å„ç§æŠ€æœ¯æœ¯è¯­å“åˆ°ã€‚è®©æˆ‘ä»¬é€šè¿‡ä¸€ä¸ªå®é™…çš„åœºæ™¯â€”â€”æ„å»ºä¸€ä¸ªç®€å•çš„åšå®¢ç³»ç»Ÿâ€”â€”æ¥çœ‹çœ‹ `rhosocial-activerecord` æ˜¯å¦‚ä½•å¸®åŠ©ä½ æ›´è½»æ¾åœ°ç¼–å†™ä»£ç çš„ã€‚

## 1. å®šä¹‰ä½ çš„æ•°æ®ï¼šæ‰€è§å³æ‰€å¾—
ä¸€åˆ‡ä»å®šä¹‰æ¨¡å‹å¼€å§‹ã€‚åœ¨ `rhosocial-activerecord` ä¸­ï¼Œä½ çš„æ¨¡å‹ **æœ¬è´¨ä¸Šå°±æ˜¯** Pydantic V2 æ¨¡å‹ã€‚

> ğŸ’¡ **ä»€ä¹ˆæ˜¯ Pydanticï¼Ÿ** Pydantic æ˜¯ä¸€ä¸ªä½¿ç”¨ Python ç±»å‹æç¤ºè¿›è¡Œæ•°æ®éªŒè¯çš„åº“ã€‚å®ƒç¡®ä¿æ•°æ®åœ¨è¿è¡Œæ—¶ç¬¦åˆæŒ‡å®šçš„ç±»å‹å’Œçº¦æŸã€‚ä½ å¯ä»¥æŠŠå®ƒæƒ³è±¡æˆæ•°æ®çš„"ç±»å‹å®‰å…¨å«å£«"â€”â€”å¦‚æœä½ è¯´ä¸€ä¸ªå­—æ®µåº”è¯¥æ˜¯ 18 åˆ° 100 ä¹‹é—´çš„æ•´æ•°ï¼ŒPydantic ä¼šç«‹å³æ‹’ç»ä»»ä½•ä¸ç¬¦åˆè¿™äº›æ¡ä»¶çš„æ•°æ®ï¼Œç”šè‡³åœ¨æ•°æ®åˆ°è¾¾æ•°æ®åº“ä¹‹å‰ã€‚
>
> è¿™æ„å‘³ç€ä½ ä¸éœ€è¦å­¦ä¹ ä¸€å¥—æ–°çš„éªŒè¯è§„åˆ™â€”â€”ä½ å¯ä»¥ä½¿ç”¨ä½ å·²ç»ç†Ÿæ‚‰çš„ Pydantic æ¨¡å¼ï¼ˆæˆ–è€…å¯ä»¥å¿«é€Ÿå­¦ä¹ ï¼‰ã€‚

> **ç‰ˆæœ¬è¦æ±‚ï¼š**
> - Python 3.8/3.9: `pydantic>=2.10.6`
> - Python 3.10+: `pydantic>=2.12`
> - åŒæ—¶æ”¯æŒ Python 3.13/3.14 è‡ªç”±çº¿ç¨‹ç‰ˆ

```python
from typing import ClassVar
from rhosocial.activerecord.model import ActiveRecord
from rhosocial.activerecord.base import FieldProxy
from pydantic import Field

class User(ActiveRecord):
    # ç›´æ¥ä½¿ç”¨ Pydantic è¿›è¡Œå¼ºå¤§çš„æ•°æ®éªŒè¯
    username: str = Field(..., min_length=3, max_length=50)
    email: str = Field(..., pattern=r"^[\w\.-]+@[\w\.-]+\.\w+$")
    age: int = Field(..., ge=18)

    # å¯ç”¨å­—æ®µä»£ç†ï¼Œä¸ºåç»­çš„æŸ¥è¯¢æä¾›ç±»å‹æ”¯æŒ
    c: ClassVar[FieldProxy] = FieldProxy()

# å°è¯•åˆ›å»ºä¸€ä¸ªéæ³•ç”¨æˆ·
# user = User(username="al", email="not-an-email", age=10) 
# ^ è¿™ä¼šç«‹å³æŠ›å‡º Pydantic ValidationErrorï¼Œç”šè‡³ä¸éœ€è¦è¿æ¥æ•°æ®åº“ï¼
```

**è¿™ä¸€æ­¥è§£å†³äº†ä»€ä¹ˆï¼Ÿ**
ä½ ä¸å†éœ€è¦æ‹…å¿ƒâ€œåƒåœ¾æ•°æ®â€è¿›å…¥æ•°æ®åº“ã€‚éªŒè¯å‘ç”Ÿåœ¨ Python å±‚é¢ï¼Œè€Œä¸”æ˜¯å³æ—¶çš„ã€‚

## 2. æ‹’ç»é‡å¤åŠ³åŠ¨ï¼šåƒæ­ç§¯æœ¨ä¸€æ ·ç»„åˆåŠŸèƒ½
å¾ˆå¿«ä½ ä¼šå‘ç°ï¼Œä¸ä»…æ˜¯ `User`ï¼Œä½ çš„ `Post` (æ–‡ç« ) å’Œ `Comment` (è¯„è®º) éƒ½éœ€è¦å”¯ä¸€çš„ IDï¼Œéƒ½éœ€è¦è®°å½•åˆ›å»ºæ—¶é—´ (`created_at`) å’Œæ›´æ–°æ—¶é—´ (`updated_at`)ã€‚

éš¾é“è¦åœ¨æ¯ä¸ªç±»é‡Œé‡å¤å†™è¿™äº›å­—æ®µå—ï¼Ÿä¸éœ€è¦ã€‚æˆ‘ä»¬æ¨å´‡ **ç»„åˆä¼˜äºç»§æ‰¿**ã€‚

```python
from rhosocial.activerecord.field import UUIDMixin, TimestampMixin

# é€šè¿‡ç»§æ‰¿ Mixinï¼Œä¸€è¡Œä»£ç è·å¾—é€šç”¨èƒ½åŠ›
class Post(UUIDMixin, TimestampMixin, ActiveRecord):
    title: str
    content: str
    
    c: ClassVar[FieldProxy] = FieldProxy()

# ç°åœ¨ Post è‡ªåŠ¨æ‹¥æœ‰äº†ï¼š
# - id (UUID ç±»å‹ï¼Œè‡ªåŠ¨ç”Ÿæˆ)
# - created_at (è‡ªåŠ¨è®°å½•åˆ›å»ºæ—¶é—´)
# - updated_at (è‡ªåŠ¨æ›´æ–°ä¿®æ”¹æ—¶é—´)
```

**è¿™ä¸€æ­¥è§£å†³äº†ä»€ä¹ˆï¼Ÿ**
ä½ çš„æ¨¡å‹ä»£ç ä¿æŒå¹²å‡€ã€ä¸“æ³¨äºä¸šåŠ¡é€»è¾‘ï¼Œé€šç”¨åŠŸèƒ½é€šè¿‡ Mixin å¤ç”¨ã€‚

## 3. åƒå†™ä»£ç ä¸€æ ·å†™æŸ¥è¯¢ï¼šå‘Šåˆ«æ‹¼å†™é”™è¯¯
æ•°æ®æœ‰äº†ï¼Œç°åœ¨æˆ‘ä»¬è¦æŸ¥è¯¢å®ƒã€‚åœ¨ä¼ ç»Ÿ ORM ä¸­ï¼Œä½ ç»å¸¸éœ€è¦å°å¿ƒç¿¼ç¿¼åœ°æ‹¼å†™å­—ç¬¦ä¸²å­—æ®µåï¼Œä¸€æ—¦æ‹¼é”™ï¼Œç¨‹åºè·‘èµ·æ¥æ‰ä¼šæŠ¥é”™ã€‚

`rhosocial-activerecord` æä¾›äº† `FieldProxy` ç³»ç»Ÿï¼ˆå³ä¸Šé¢çš„ `c`ï¼‰ï¼Œè®©ä½ çš„æŸ¥è¯¢ä»£ç åƒæ™®é€š Python ä»£ç ä¸€æ ·æ‹¥æœ‰æ™ºèƒ½æç¤ºã€‚

```python
# âŒ ç³Ÿç³•çš„å†™æ³•ï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰
# å¦‚æœä½ æŠŠ 'username' æ‹¼æˆäº† 'usrname'ï¼Œåªæœ‰è¿è¡Œæ—¶æ‰çŸ¥é“é”™äº†
# User.query().where("usrname == 'alice'")

# âœ… æˆ‘ä»¬çš„å†™æ³•
# IDE ä¼šè‡ªåŠ¨è¡¥å…¨ .usernameï¼Œå¦‚æœæ‹¼é”™ï¼ŒIDE ä¼šç›´æ¥æ ‡çº¢è­¦å‘Š
users = User.query().where(User.c.username == "alice").all()
```

**è¿™ä¸€æ­¥è§£å†³äº†ä»€ä¹ˆï¼Ÿ**
å°†è¿è¡Œæ—¶é”™è¯¯æå‰åˆ°äº†ç¼–å†™ä»£ç æ—¶ï¼Œåˆ©ç”¨ IDE çš„èƒ½åŠ›å¤§å¹…å‡å°‘ä½çº§ bugã€‚

## 4. æ—¢è¦å®‰å…¨ï¼Œåˆè¦é€Ÿåº¦ï¼šçµæ´»çš„æ•°æ®è®¿é—®
ä½ çš„åšå®¢ç«äº†ï¼Œç°åœ¨ä½ éœ€è¦å¯¼å‡ºä¸€ç™¾ä¸‡æ¡æ—¥å¿—è¿›è¡Œåˆ†æã€‚
*   ä½¿ç”¨å®Œæ•´å¯¹è±¡ä¸€ä¸ªä¸ªå¤„ç†å¤ªæ…¢äº†ï¼Œå› ä¸ºåˆ›å»ºä¸€ç™¾ä¸‡ä¸ª Python å¯¹è±¡å¼€é”€å¾ˆå¤§ã€‚
*   å†™åŸç”Ÿ SQL åˆå®¹æ˜“å‡ºé”™ä¸”éš¾ä»¥ç»´æŠ¤ã€‚

`rhosocial-activerecord` å…è®¸ä½ åœ¨åŒä¸€ä¸ªåº“ä¸­æ— ç¼åˆ‡æ¢ï¼š

```python
# åœºæ™¯ Aï¼šå¤„ç†ç”¨æˆ·æ³¨å†Œï¼ˆéœ€è¦å®Œæ•´æ ¡éªŒï¼‰
# ä½¿ç”¨ ActiveRecord å¯¹è±¡ï¼Œäº«å—å®Œæ•´çš„ Pydantic éªŒè¯å’Œç”Ÿå‘½å‘¨æœŸé’©å­
user = User(username="bob", email="bob@example.com", age=20)
user.save()

# åœºæ™¯ Bï¼šç”Ÿæˆå¤§æ•°æ®æŠ¥è¡¨ï¼ˆè¿½æ±‚æè‡´æ€§èƒ½ï¼‰
# ä½¿ç”¨ aggregate()ï¼Œç›´æ¥è·å–å­—å…¸åˆ—è¡¨ï¼Œè·³è¿‡å¯¹è±¡åˆ›å»ºå’ŒéªŒè¯ï¼Œé€Ÿåº¦åª²ç¾åŸç”Ÿ SQL
# è¿™é‡Œæˆ‘ä»¬ä¾ç„¶ä½¿ç”¨ User.c.active äº«å—ç±»å‹æç¤ºï¼Œä½†ç»“æœæ˜¯åŸå§‹æ•°æ®
raw_data = User.query().where(User.c.age > 20).limit(100000).aggregate()
```

**è¿™ä¸€æ­¥è§£å†³äº†ä»€ä¹ˆï¼Ÿ**
ä½ ä¸å¿…å› ä¸ºæ€§èƒ½é—®é¢˜è€Œè¢«è¿«æ”¾å¼ƒ ORMï¼Œä¹Ÿä¸å¿…å› ä¸ºè¿½æ±‚æ€§èƒ½è€Œç‰ºç‰²å…³é”®ä¸šåŠ¡çš„å®‰å…¨æ€§ã€‚

## 5. é›¶è´Ÿæ‹…æµ‹è¯•ï¼šä¸éœ€è¦æ•°æ®åº“ä¹Ÿèƒ½æµ‹è¯• SQL
æœ€åï¼Œä½ è¦ä¸Šçº¿äº†ã€‚ä½ å†™äº†ä¸€ä¸ªå¤æ‚çš„æŸ¥è¯¢é€»è¾‘ï¼Œæƒ³å†™ä¸ªå•å…ƒæµ‹è¯•éªŒè¯å®ƒã€‚
é€šå¸¸ä½ éœ€è¦ï¼šå®‰è£… Docker -> å¯åŠ¨ MySQL -> åˆ›å»ºè¡¨ -> æ’å…¥æ•°æ® -> è¿è¡Œæµ‹è¯• -> æ¸…ç†æ•°æ®... å¤ªéº»çƒ¦äº†ï¼

æˆ‘ä»¬å¯ä»¥ç›´æ¥æµ‹è¯•â€œç”Ÿæˆçš„ SQL æ˜¯å¦æ­£ç¡®â€ï¼š

```python
# ç›´æ¥æŸ¥çœ‹ç”Ÿæˆçš„ SQLï¼Œæ— éœ€è¿æ¥ä»»ä½•æ•°æ®åº“
sql, params = User.query().where(User.c.username == "alice").to_sql()

# æ–­è¨€ç”Ÿæˆçš„ SQL ç¬¦åˆé¢„æœŸ
assert "SELECT * FROM users WHERE username = ?" in sql
assert params == ("alice",)
```

**è¿™ä¸€æ­¥è§£å†³äº†ä»€ä¹ˆï¼Ÿ**
ä½ çš„å•å…ƒæµ‹è¯•å¯ä»¥é£å¿«è¿è¡Œï¼Œä¸éœ€è¦ä»»ä½•å¤–éƒ¨ç¯å¢ƒä¾èµ–ã€‚


## åŒæ­¥å¼‚æ­¥å¯¹ç­‰ï¼šè·¨èŒƒå¼åŠŸèƒ½ç­‰ä»·æ€§ (Sync-Async Parity: Equivalent Functionality Across Paradigms)

`rhosocial-activerecord` çš„ä¸€ä¸ªåŸºæœ¬è®¾è®¡åŸåˆ™æ˜¯**åŒæ­¥å¼‚æ­¥å¯¹ç­‰**ï¼Œè¿™æ„å‘³ç€åŒæ­¥å’Œå¼‚æ­¥å®ç°æä¾›ç­‰æ•ˆçš„åŠŸèƒ½å’Œä¸€è‡´çš„ APIã€‚

### åŒæ­¥å’Œå¼‚æ­¥æ¨¡å‹ (Synchronous and Asynchronous Models)

åŒæ­¥å’Œå¼‚æ­¥æ¨¡å‹å…±äº«ç›¸åŒçš„ç»“æ„å’Œ APIï¼š

```python
# åŒæ­¥æ¨¡å‹
class User(ActiveRecord):
    username: str
    
    @classmethod
    def table_name(cls) -> str:
        return 'users'

# å¼‚æ­¥æ¨¡å‹  
class AsyncUser(AsyncActiveRecord):
    username: str
    
    @classmethod
    def table_name(cls) -> str:
        return 'users'
```

### ä¸€è‡´çš„æŸ¥è¯¢æ¥å£ (Consistent Query Interface)

åŒæ­¥å’Œå¼‚æ­¥æŸ¥è¯¢æä¾›ç›¸åŒçš„æ–¹æ³•ï¼Œå…·æœ‰ç›¸åŒçš„ç­¾åï¼š

```python
# åŒæ­¥æŸ¥è¯¢
users = User.query().where(User.c.username == 'john').all()

# å¼‚æ­¥æŸ¥è¯¢ - ç›¸åŒçš„ APIï¼Œåªéœ€ä½¿ç”¨ await
async def get_users():
    users = await AsyncUser.query().where(AsyncUser.c.username == 'john').all()
    return users
```

è¿™ç§å¯¹ç­‰æ€§ä½¿å¼€å‘äººå‘˜èƒ½å¤Ÿåœ¨åŒæ­¥å’Œå¼‚æ­¥ä¸Šä¸‹æ–‡ä¹‹é—´æ— ç¼è¿‡æ¸¡ï¼Œè€Œæ— éœ€å­¦ä¹ ä¸åŒçš„ API æˆ–ç‰ºç‰²åŠŸèƒ½ã€‚

