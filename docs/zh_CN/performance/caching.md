# 缓存机制 (Caching)

本库包含多级缓存优化，旨在提高应用程序性能并减少数据库负载。

1.  **元数据缓存**: 字段映射、列名信息只解析一次，后续操作直接复用。
2.  **关系缓存**: 模型实例上的关联关系数据（如 `user.posts()`）在首次访问或预加载后会被缓存。

## N+1 查询问题与解决方案

### 什么是 N+1 问题？

N+1 问题是 ORM 中常见的性能陷阱。当你查询 N 个对象，然后遍历这些对象并访问它们的关联关系时，如果每次访问都触发一次数据库查询，那么总共会执行 N+1 次查询（1 次查询列表 + N 次查询关联）。

**低效代码示例 (N+1)**：

```python
# 1 次查询：获取前 10 个用户
users = User.query().limit(10).all()

for user in users:
    # N 次查询：每次循环都触发一次数据库查询来获取 profile
    # 注意：访问关联方法 user.profile() 会触发查询（如果未缓存）
    print(user.profile().bio)

# 总查询次数：1 + 10 = 11 次
```

### 解决方案：预加载 (Eager Loading)

使用 `with_` 方法可以一次性预加载所需的关联数据。ORM 会自动将查询到的关联数据填充到模型实例的**关系缓存**中。

**高效代码示例 (预加载)**：

```python
# 1 次查询：获取用户，并同时获取 profile
# ORM 会自动执行优化，通常只需要 1-2 次 SQL 查询即可完成所有数据加载
users = User.query().with_("profile").limit(10).all()

for user in users:
    # 0 次查询：数据已在缓存中，直接内存访问
    print(user.profile().bio)
```

### 缓存的工作原理

当使用 `with_` 时：
1.  主查询执行，获取 `users` 列表。
2.  ORM 收集所有用户的 ID。
3.  ORM 执行一次批量查询，获取这些用户对应的 `profile` 数据。
4.  ORM 将 `profile` 数据映射回对应的 `user` 实例，并存储在实例内部的字典中（即关系缓存）。
5.  后续调用 `user.profile()` 时，ORM 检查缓存，发现已有数据，直接返回，不再访问数据库。

## 清除关系缓存

有时你需要强制重新从数据库加载最新数据（例如，关联数据在其他地方被修改了）。你可以通过以下方式清除缓存：

```python
user = User.find(1)
posts = user.posts()  # 触发查询并缓存

# ... 在其他地方更新了 posts ...

# 方法 1：清除指定关系的缓存
user.clear_relation_cache('posts')

# 方法 2：清除该实例所有关系的缓存
user.clear_relation_cache()

# 方法 3：通过关联访问器上的辅助方法
user.posts.clear_cache()
```

> **注意**：关系缓存是**实例级别**的。不同的模型实例（即使代表同一行数据库记录）拥有各自独立的缓存。
